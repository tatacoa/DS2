plot(1:7,avesw.vec,type="b",ylim=c(0,0.6))
avesw.vec # cual tiene el largest mean silhouette width? todas son muy malas menos de 0.4
help(USArrests)
summary(USArrests)
head(USArrests)
colnames(USArrests)
row.names(USArrests)<-state.abb
pairs(USArrests)
# PAM clustering with 4 clusters
pam.out<-pam(USArrests,k=4)
clusplot(pam.out,labels=3)
# silhouette width over 0.4 is good
?silhouette
sp<-silhouette(pam.out); sp
plot(sp,col=1:4)
mean(sp[,"sil_width"])
abline(v=mean(sp[,"sil_width"]))
# The mean silhouette width can be used to assess which is the best number of clusters
avesw.vec<-rep(NA,7)
for(i in 2:7)
avesw.vec[i]<-mean(silhouette(pam(USArrests,k=i))[,"sil_width"])
plot(1:7,avesw.vec,type="b",ylim=c(0,0.6))
avesw.vec # cual tiene el largest mean silhouette width? 2???
# Rerun the PAM algorithm with the optimal number of clusters
pam.out<-pam(USArrests,k=2); pam.out
clusplot(pam.out,labels=3)
sp<-silhouette(pam.out)
plot(sp,col=1:2)
abline(v=mean(sp[,"sil_width"]))
Element <- c(1:6)
X1 <- c(4, 5, 6, 10, 14, 15)
X2 <- c(2, ,5, 11, 2, 7, 9)
dat <- cbind(Element, X1, X2)
Element <- c(1:6)
X1 <- c(4, 5, 6, 10, 14, 15)
X2 <- c(2, ,5, 11, 2, 7, 9)
dat <- cbind(Element, X1, X2)
Element <- c(1:6)
X1 <- c(4, 5, 6, 10, 14, 15)
X2 <- c(2, ,5, 11, 2, 7, 9)
dat <- cbind(Element, X1, X2)
Element
X1
X2
X2 <- c(2, ,5, 11, 2, 7, 9)
X3 <- c(2, ,5, 11, 2, 7, 9)
X1 <- c(4, 5, 6, 10, 14, 15)
X2 <- c(2, 5, 11, 2, 7, 9)
dat <- cbind(Element, X1, X2)
dat <- cbind(Element, X1, X2); dat
dist(dat)
?dist
dist(dat, digits = 1)
dist(dat[,2:3])
dist(dat)
dat
dist(round(dat, digits = 1)
)
round(dist(dat, digits = 1))
round(dist(dat), digits = 1)
nci.labs=NCI60$labs
nci.data=NCI60$data
dim(nci.data)
table(nci.labs)
Cols=function(vec){
cols=rainbow(length(unique(vec)))
return(cols[as.numeric(as.factor(vec))]) }
# plot the principal component score vectors
par(mfrow=c(1,2))
plot(pr.out$x[,1:2], col=Cols(nci.labs), pch=19,
xlab="Z1",ylab="Z2")
plot(pr.out$x[,c(1,3)], col=Cols(nci.labs), pch=19,
xlab="Z1",ylab="Z3")
pr.out=prcomp(nci.data, scale=TRUE)
Cols=function(vec){
cols=rainbow(length(unique(vec)))
return(cols[as.numeric(as.factor(vec))]) }
# plot the principal component score vectors
par(mfrow=c(1,2))
plot(pr.out$x[,1:2], col=Cols(nci.labs), pch=19,
xlab="Z1",ylab="Z2")
plot(pr.out$x[,c(1,3)], col=Cols(nci.labs), pch=19,
xlab="Z1",ylab="Z3")
summary(pr.out)
plot(pr.out)
pve=100*pr.out$sdev^2/sum(pr.out$sdev^2)
par(mfrow=c(1,2))
plot(pve, type="o", ylab="PVE", xlab="Principal Component",
col =" blue ")
plot(cumsum(pve), type="o", ylab="Cumulative PVE", xlab="
Principal Component ", col =" brown3 ")
# PVE can be also computed like this<
summary(pr.out)$importance[2,]
summary(pr.out)$importance[3,]
plot(cumsum(pve), type="o", ylab="Cumulative PVE", xlab="
Principal Component ", col =" brown3 ")
plot(pve, type="o", ylab="PVE", xlab="Principal Component",
col =" blue ")
plot(cumsum(pve), type="o", ylab="Cumulative PVE", xlab="
Principal Component ", col =" brown3 ")
# PVE can also be computed like this:
summary(pr.out)$importance[2,]
par(mfrow=c(1,2))
plot(pve, type="o", ylab="PVE", xlab="Principal Component",
col =" blue ")
plot(cumsum(pve), type="o", ylab="Cumulative PVE", xlab="
Principal Component ", col =" brown3 ")
# PAM
# scale genes
sd.data=scale(nci.data)
par(mfrow=c(1,3))
data.dist=dist(sd.data)
data.dist=dist(sd.data) ; data.dist
plot(hclust(data.dist), labels=nci.labs, main="Complete
Linkage", xlab="", sub="",ylab="")
plot(hclust(data.dist, method="average"), labels=nci.labs,
main="Average Linkage", xlab="", sub="",ylab="")
plot(hclust(data.dist, method="single"), labels=nci.labs,
main="Single Linkage", xlab="", sub="",ylab="")
par(mfrow=c(3,1))
data.dist=dist(sd.data) ; data.dist
plot(hclust(data.dist), labels=nci.labs, main="Complete
Linkage", xlab="", sub="",ylab="")
plot(hclust(data.dist, method="average"), labels=nci.labs,
main="Average Linkage", xlab="", sub="",ylab="")
plot(hclust(data.dist, method="single"), labels=nci.labs,
main="Single Linkage", xlab="", sub="",ylab="")
hc.out=hclust(dist(sd.data))
hc.clusters=cutree(hc.out,4)
table(hc.clusters,nci.labs)
par(mfrow=c(1,1))
plot(hc.out, labels=nci.labs)
abline(h=139, col="red")
cutree(hc.out,4)
hc.out
# The same but using kmeans
km.out=kmeans(sd.data, 4, nstart=20)
km.clusters=km.out$cluster
table(km.clusters ,hc.clusters )
hc.out=hclust(dist(pr.out$x[,1:5]))
plot(hc.out, labels=nci.labs, main="Hier. Clust. on First
Five Score Vectors ")
table(cutree(hc.out,4), nci.labs)
setwd("~/DS2")
lab.measure <- read.csv2("LabMeasurements-Color-Card.csv")
master.color <- read.csv2("MasterColorCard.csv") # CMYKS colors are in p1- p5 (neglect?)
# instantiate the iterators and the dataframe to store the values in
lab.distances <- as.data.frame(0)
k <- 1
l <- 1
i <- 1
# choose the amount of sheets to scan through (max=13), max value will take ~5 minutes
sheets <- 3
# iterate through sheets
for (m in c(1:(sheets*42))){
# iterate through cards
for (j in c(3:194)){
# if iterator is not dividable by 3, jump to the next j i.e. jumping over the Lab sequences
if (j%%3 != 0){
}else{
if (i > 64){
i <- 1
}
# collection of all values from CIE94 (https://en.wikipedia.org/wiki/Color_difference)
dL <- master.color[i,9] - lab.measure[m,j]
C1 <- sqrt((master.color[i,10])^2 + (master.color[i,11])^2)
C2 <- sqrt((lab.measure[m,j+1])^2 + (lab.measure[m,j+2])^2)
dC <- C1-C2
da <- master.color[i,10] - lab.measure[m,j+1]
db <- master.color[i,11] - lab.measure[m,j+2]
dH <- sqrt(da^2 + db^2 - dC^2)
Sl <- 1
kL <- 1
K1 <- 0.045
K2 <- 0.015
Sc <- 1 + K1*C1
Sh <- 1 + K2*C1
# final distance value
dE <- sqrt((dL/(kL * Sl))^2 + (dC/Sc)^2 + (dH/Sh)^2)
# in the storage dataframe, jump to the next row for the next card if k > 64
if (k < 65){
lab.distances[l,k] <- dE
k <- k + 1
}else{
l <- l +1
lab.distances[l, 1] <- dE
k <- 2
}
#print(i) #to check that everything is running smooth
i <- i + 1
}
}
}
View(lab.distances)
dim(lab.distances)
lab.measure <- read.csv2("LabMeasurements-Color-Card.csv")
master.color <- read.csv2("MasterColorCard.csv") # CMYKS colors are in p1- p5 (neglect?)
# instantiate the iterators and the dataframe to store the values in
lab.distances <- as.data.frame(0)
k <- 1
l <- 1
i <- 1
# choose the amount of sheets to scan through (max=13), max value will take ~5 minutes
sheets <- 13
# iterate through sheets
for (m in c(1:(sheets*42))){
# iterate through cards
for (j in c(3:194)){
# if iterator is not dividable by 3, jump to the next j i.e. jumping over the Lab sequences
if (j%%3 != 0){
}else{
if (i > 64){
i <- 1
}
# collection of all values from CIE94 (https://en.wikipedia.org/wiki/Color_difference)
dL <- master.color[i,9] - lab.measure[m,j]
C1 <- sqrt((master.color[i,10])^2 + (master.color[i,11])^2)
C2 <- sqrt((lab.measure[m,j+1])^2 + (lab.measure[m,j+2])^2)
dC <- C1-C2
da <- master.color[i,10] - lab.measure[m,j+1]
db <- master.color[i,11] - lab.measure[m,j+2]
dH <- sqrt(da^2 + db^2 - dC^2)
Sl <- 1
kL <- 1
K1 <- 0.045
K2 <- 0.015
Sc <- 1 + K1*C1
Sh <- 1 + K2*C1
# final distance value
dE <- sqrt((dL/(kL * Sl))^2 + (dC/Sc)^2 + (dH/Sh)^2)
# in the storage dataframe, jump to the next row for the next card if k > 64
if (k < 65){
lab.distances[l,k] <- dE
k <- k + 1
}else{
l <- l +1
lab.distances[l, 1] <- dE
k <- 2
}
#print(i) #to check that everything is running smooth
i <- i + 1
}
}
}
dim(lab.distances)
# Load data
lab <- read.csv2("LabMeasurements-Color-Card.csv")
master <- read.csv2("MasterColorCard.csv")
deltae <- matrix(NA,nrow = 546, ncol=66, byrow = TRUE)
# put the values for the first two columns (indicates de card position in a sheet)
deltae[,1] <- lab[,1]; deltae[,1]
deltae[,2] <- lab[,2]; deltae[,c(1,2)]
# function to compute a deltae between two colors (color distance)
foo <- function (x,y,l,a,b) {
m <- master[which(master$Crow ==  x & master$Ccol == y),]
ml <- m$L
ma <- m$a
mb <- m$b
del <- sqrt((ml - l)^2 + (ma - a)^2 + (mb - b)^2)
del
}
foo(1,1,55.5869,0.1352,2.1851)
foo(1,1,51.641,0.169,3.054)
# take a row (single card and compute color distance deltae)
x <- lab[1,]; x
cardmat <- matrix(x[,-c(1:2)],nrow=64,ncol=3,byrow=TRUE); cardmat
colnames(cardmat) = c("L","a","b")
cardmat
# for loop to compute the color distance (deltae) of a card ...
v <- {}
for (i in 1:64) {
cardmat[i,] -> mata
master[i,] -> matb
del <- sqrt((mata$L - matb$L)^2 + (mata$a - matb$a)^2 + (mata$b - matb$b)^2)
v[i] <- del
}
v
View(lab.distances)
# instantiate the iterators and the dataframe to store the values in
lab.distances <- as.data.frame(0)
k <- 1
l <- 1
i <- 1
# choose the amount of sheets to scan through (max=13), max value will take ~5 minutes
sheets <- 1
# iterate through sheets
for (m in c(1:(sheets*1))){
# iterate through cards
for (j in c(3:194)){
# if iterator is not dividable by 3, jump to the next j i.e. jumping over the Lab sequences
if (j%%3 != 0){
}else{
if (i > 64){
i <- 1
}
# collection of all values from CIE94 (https://en.wikipedia.org/wiki/Color_difference)
dL <- master.color[i,9] - lab.measure[m,j]
C1 <- sqrt((master.color[i,10])^2 + (master.color[i,11])^2)
C2 <- sqrt((lab.measure[m,j+1])^2 + (lab.measure[m,j+2])^2)
dC <- C1-C2
da <- master.color[i,10] - lab.measure[m,j+1]
db <- master.color[i,11] - lab.measure[m,j+2]
dH <- sqrt(da^2 + db^2 - dC^2)
Sl <- 1
kL <- 1
K1 <- 0.045
K2 <- 0.015
Sc <- 1 + K1*C1
Sh <- 1 + K2*C1
# final distance value
dE <- sqrt((dL/(kL * Sl))^2 + (dC/Sc)^2 + (dH/Sh)^2)
# in the storage dataframe, jump to the next row for the next card if k > 64
if (k < 65){
lab.distances[l,k] <- dE
k <- k + 1
}else{
l <- l +1
lab.distances[l, 1] <- dE
k <- 2
}
#print(i) #to check that everything is running smooth
i <- i + 1
}
}
}
View(lab.distances)
v
cardmat
# Load data
lab <- read.csv2("LabMeasurements-Color-Card.csv")
master <- read.csv2("MasterColorCard.csv")
deltae <- matrix(NA,nrow = 546, ncol=66, byrow = TRUE)
# put the values for the first two columns (indicates de card position in a sheet)
deltae[,1] <- lab[,1]; deltae[,1]
deltae[,2] <- lab[,2]; deltae[,c(1,2)]
deltae
dim(deltae)
colnames(deltae)
rownames(deltae)
lab[,1]; deltae[,1]
lab[,2]; deltae[,c(1,2)]
deltae[,c(1,2)]
colnames(lab)
colnames(deltae) <- colnames(lab)
length(colnames(deltae))
length(colnames(lab))
colnames(deltae) <- colnames(lab)
dim(deltae); dim(lab)
View(lab.measure)
colnames(deltae[,1]) <- Row
colnames(deltae[,1]) <- "Row"
rownames(lab.measure)
colnames(lab.measure)
View(master)
seq(c(11:18)
)
seq(11:18)
c(11:18)
c(11:18, 21:28)
c(11:18, 21:28, 31:38, 41:48, 51:58, 61:68, 71:78, 81:88)
colnames(deltae) <- c("Row", "Column", c(11:18, 21:28, 31:38, 41:48, 51:58, 61:68, 71:78, 81:88))
c(11:18, 21:28, 31:38, 41:48, 51:58, 61:68, 71:78, 81:88)
colnames(deltae)
dim(deltae)
c(1.1:1.8)
lab[1,]
length(lab.measure)
dim(deltae)
length(lab)
dim(lab)
dim(lab)[1]
length(row.names(lab)
)
1:length(row.names(lab)
)
for i in (1:length(row.names(lab)) {
for (i in 1:length(row.names(lab)) {
for (i in 1:length(row.names(lab))) {
cardmatrix <- matrix(lab[i,-c(1:2)],nrow=64,ncol=3,byrow=TRUE)
colnames(cardmatrix) = c("L","a","b")
for (j in 1:64) {
cardmatrix[j,] -> matrixA
master[j,] -> matrixB
distance <- sqrt((matrixA$L - matrixB$L)^2 + (matrixA$a - matrixB$a)^2 + (matrixA$b - matrixB$b)^2)
}
deltae[i] <- distance
}
View(deltae)
for (i in 1:length(row.names(lab))) {
cardmatrix <- matrix(lab[i,-c(1:2)],nrow=64,ncol=3,byrow=TRUE)
colnames(cardmatrix) = c("L","a","b")
for (j in 1:64) {
cardmatrix[j,] -> matrixA
master[j,] -> matrixB
distance <- sqrt((matrixA$L - matrixB$L)^2 + (matrixA$a - matrixB$a)^2 + (matrixA$b - matrixB$b)^2)
}
deltae[i,] <- distance
}
View(deltae)
for (i in 1:length(row.names(lab))) {
cardmatrix <- matrix(lab[i,-c(1:2)],nrow=64,ncol=3,byrow=TRUE)
colnames(cardmatrix) = c("L","a","b")
for (j in 1:64) {
cardmatrix[j,] -> matrixA
master[j,] -> matrixB
distance <- sqrt((matrixA$L - matrixB$L)^2 + (matrixA$a - matrixB$a)^2 + (matrixA$b - matrixB$b)^2)
}
deltae[i,-c(1:2)] <- distance
}
View(deltae)
deltae <- matrix(NA,nrow = 546, ncol=66, byrow = TRUE)
# put the values for the first two columns (indicates de card position in a sheet)
deltae[,1] <- lab[,1]; deltae[,1]
deltae[,2] <- lab[,2]; deltae[,c(1,2)]
dim(deltae); dim(lab)
colnames(deltae) <- c("Row", "Column", c(11:18, 21:28, 31:38, 41:48, 51:58, 61:68, 71:78, 81:88))
colnames(deltae)
distance
j
i
cardmatrix
View(lab)
View(deltae)
matrixA$L
matrixB
distance
# take a row (single card and compute color distance deltae)
x <- lab[1,]; x
cardmat <- matrix(x[,-c(1:2)],nrow=64,ncol=3,byrow=TRUE); cardmat
colnames(cardmat) = c("L","a","b")
cardmat
# for loop to compute the color distance (deltae) of a card ...
v <- {}
for (i in 1:64) {
cardmat[i,] -> mata
master[i,] -> matb
del <- sqrt((mata$L - matb$L)^2 + (mata$a - matb$a)^2 + (mata$b - matb$b)^2)
v[i] <- del
}
v
distance_single <- {}
distance_row <- {}
for (i in 1:length(row.names(lab))) {
cardmatrix <- matrix(lab[i,-c(1:2)],nrow=64,ncol=3,byrow=TRUE)
colnames(cardmatrix) = c("L","a","b")
for (j in 1:64) {
cardmatrix[j,] -> matrixA
master[j,] -> matrixB
distance_single <- sqrt((matrixA$L - matrixB$L)^2 + (matrixA$a - matrixB$a)^2 + (matrixA$b - matrixB$b)^2)
distance_row[j] <- distance_single
}
deltae[i,-c(1:2)] <- distance_row
}
head(deltae)
lab.measure <- read.csv2("LabMeasurements-Color-Card.csv")
master.color <- read.csv2("MasterColorCard.csv") # CMYKS colors are in p1- p5 (neglect?)
# instantiate the iterators and the dataframe to store the values in
lab.distances <- as.data.frame(matrix(c(1:3),nrow = 1))
k <- 1
l <- 1
i <- 1
# choose the amount of sheets to scan through (max=13), max will take ~5 min
sheets <- 13
# iterate through sheets
for (m in c(1:(sheets*42))){
# iterate through cards
for (j in c(3:194)){
# if iterator is not dividable by 3, jump to the next j i.e. jumping over the Lab sequences
if (j%%3 != 0){
}else{
if (i > 64){
i <- 1
}
# collection of all values from CIE94 (https://en.wikipedia.org/wiki/Color_difference)
dL <- master.color[i,9] - lab.measure[m,j]
C1 <- sqrt((master.color[i,10])^2 + (master.color[i,11])^2)
C2 <- sqrt((lab.measure[m,j+1])^2 + (lab.measure[m,j+2])^2)
dC <- C1-C2
da <- master.color[i,10] - lab.measure[m,j+1]
db <- master.color[i,11] - lab.measure[m,j+2]
dH <- sqrt(da^2 + db^2 - dC^2)
Sl <- 1
kL <- 1
K1 <- 0.045
K2 <- 0.015
Sc <- 1 + K1*C1
Sh <- 1 + K2*C1
# final distance value
dE <- sqrt((dL/(kL * Sl))^2 + (dC/Sc)^2 + (dH/Sh)^2)
# in the storage dataframe, jump to the next row for the next card if k > 64
if (k < 65){
lab.distances[l,k + 2] <- dE
k <- k + 1
}else{
# adding row label from lab.measure file
lab.distances[l, 1] <- lab.measure[l, 1]
lab.distances[l, 2] <- lab.measure[l, 2]
l <- l +1
lab.distances[l, 3] <- dE
k <- 2
}
#print(i) #to check that everything is running smooth
i <- i + 1
}
}
# adding the labels for the two very last rows
lab.distances[l, 1] <- lab.measure[l, 1]
lab.distances[l, 2] <- lab.measure[l, 2]
}
head(lab.distances)
View(lab.distances)
quit()
